<html>
  <head>
    <title>Simple Geometry Test</title>
  </head>

  <style>
  body {margin: 0;}
  canvas {width: 100%; height: 100%;}
  </style>

  <body>
	<link rel="shortcut icon" href="#">

   
    <style>
    			body {
    				font-family: Monospace;
    				background-color: #000;
    				color: #fff;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 10px;
    				width: 100%;
    				text-align: center;
    			}
    </style>

    <div id="info">
      <p>24428486 - Introduction To Computer Graphics Task 3.4</p>
    </div>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
		</script>
    <!-- <script type="x-shader/x-vertex" id="vertexShader">
      varying vec2 vUv;
      void main()
      {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
      uniform sampler2D gifTexture;
      uniform float time;
      uniform float frameCount;
      uniform float frameDuration;
      varying vec2 vUv;

      void main() {
        float frameProgress = mod(time, frameCount * frameDuration) / frameDuration;
        float frameIndex = floor(mod(time, frameCount * frameDuration) / frameDuration);
        vec2 uv = vec2(vUv.x, vUv.y + (1.0 - frameProgress));
        uv.y += frameIndex / frameCount;
        vec4 color = texture2D(gifTexture, vUv);
        gl_FragColor = color;
      }
    </script> -->
		
	<script type="module">

	import * as THREE from 'three';
	import { OrbitControls } from './build/controls/OrbitControls.js';
  import { FBXLoader } from './build/loaders/FBXLoader.js';
  import { GUI } from './build/gui/lil-gui.module.min.js';

      var scene = new THREE.Scene( );
      scene.background = new THREE.Color(135/255,206/255,235/255);
      var renderer = new THREE.WebGLRenderer( );
      renderer.setSize(window.innerWidth,window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFShadowMap;

      document.body.appendChild(renderer.domElement );

      var ratio = window.innerWidth/window.innerHeight;
      var camera = new THREE.PerspectiveCamera(45,ratio,0.1,1000);
      camera.position.set(0,0,10);
  	  camera.lookAt(0,0,0);
      
      var controls = new OrbitControls( camera, renderer.domElement );

      var cameralight = new THREE.PointLight( new THREE.Color(1,1,1), 0.5 );
      camera.add( cameralight );
      scene.add(camera);

      var ambientlight = new THREE.AmbientLight(new THREE.Color(1,1,1), 0.5);
      scene.add(ambientlight);
      
      var dirLight = new THREE.SpotLight(new THREE.Color(1,1,1), 0.5);
      dirLight.castShadow = true;
      dirLight.position.x = 10;
      dirLight.position.y = 10;
      scene.add(dirLight);


      //Add TV to scene
      var modelLoader = new FBXLoader();
      var textureLoader = new THREE.TextureLoader();

      // var testGif = textureLoader.load("./models/rickroll-roll.gif");
      // testGif.minFilter = THREE.NearestFilter;
      // testGif.maagFilter = THREE.NearestFilter;
      // testGif.wrapS = THREE.RepeatWrapping;

      // const customMaterial = new THREE.ShaderMaterial({
      //   uniforms: {
      //     time: { value: 0.0 },
      //     gifTexture: { value: testGif},
      //     frameCount: {value: 54},
      //     frameDuration: {value: 1.0/24.0},
      //   },
      //   vertexShader: document.getElementById('vertexShader').textContent,
      //   fragmentShader: document.getElementById('fragmentShader').textContent,
      // });

      // var testPlane = new THREE.PlaneGeometry(10,10,10, 10);
      // var plane = new THREE.Mesh(testPlane, customMaterial);
      // Load the GIF file and create a sprite sheet

      // scene.add(plane);

      var runnerTexture = textureLoader.load( './models/rickroll.jpg' );
      var annie = new TextureAnimator( runnerTexture, 5, 11, 54, 100 ); // texture, #horiz, #vert, #total, duration.
      var runnerMaterial = new THREE.MeshBasicMaterial( { map: runnerTexture, side:THREE.DoubleSide } );
      var runnerGeometry = new THREE.PlaneGeometry(50, 50, 1, 1);
      var runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
      runner.position.set(0,0,0);
      scene.add(runner);
      
      
      function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) 
      {	
        // note: texture passed by reference, will be updated by the update function.
          
        this.tilesHorizontal = tilesHoriz;
        this.tilesVertical = tilesVert;
        // how many images does this spritesheet contain?
        //  usually equals tilesHoriz * tilesVert, but not necessarily,
        //  if there at blank tiles at the bottom of the spritesheet. 
        this.numberOfTiles = numTiles;
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
        texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

        // how long should each image be displayed?
        this.tileDisplayDuration = tileDispDuration;

        // how long has the current image been displayed?
        this.currentDisplayTime = 0;

        // which image is currently being displayed?
        this.currentTile = 0;
          
        this.update = function( milliSec )
        {
          this.currentDisplayTime += milliSec;
          while (this.currentDisplayTime > this.tileDisplayDuration)
          {
            this.currentDisplayTime -= this.tileDisplayDuration;
            this.currentTile++;
            if (this.currentTile == this.numberOfTiles)
              this.currentTile = 0;
            var currentColumn = this.currentTile % this.tilesHorizontal;
            texture.offset.x = currentColumn / this.tilesHorizontal;
            var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
            texture.offset.y = currentRow / this.tilesVertical;
            console.log(currentRow);
          }
        };
      }

      var clock = new THREE.Clock();
      function animatePlane()
      {
        requestAnimationFrame(animatePlane);
        var delta = clock.getDelta();
        annie.update(1000*delta);
        renderer.render(scene,camera);
      }
      animatePlane();



      var images = ["Standby.png", "Heightmap.png"];
      var imageIndex = 0;

      var screen;
      var screenOn = false;
      var screenOffMaterial;
      var screenOnMaterial = new THREE.MeshStandardMaterial();

      var knob;

      var TV;
      modelLoader.load("./models/TV/TV.fbx", function(object)
      {
        TV = object;
        scene.add(TV);
        //console.log(TV);
        TV.traverse(function(child)
        {
          if(child.isMesh)
          { 
            child.castShadow = true;
          }
          if(child.name == "Screen")
          {
            screen = child;
            screenOffMaterial = child.material;
            screenOnMaterial.map = textureLoader.load("./models/Standby.png");
          }
          if(child.name == "Knob")
          {
            knob = child;
          }
        });
      });

      function toggleScreen()
      {
        if(screenOn)
        {
          screen.material = runnerMaterial;
        }
        else
        {
          screen.material = screenOffMaterial;
        }
      }

      function changeScreen()
      {
        imageIndex++;
        if(imageIndex >= images.length)
        {
          imageIndex = 0;
        }
        screenOnMaterial.map = textureLoader.load("./models/" + images[imageIndex]);
      }


      var raycaster = new THREE.Raycaster();
      function onDocumentMouseDown( event ) {
        var mouse = new THREE.Vector2;
        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( scene.children, true );

        if(intersects.length > 0)
        {
          switch(intersects[0].object.name)
          {
            case "Power_Button":
              screenOn = !screenOn;
              toggleScreen();
              break;
            case "Knob":
              changeScreen()
              break;
          }
        }
      }
      
      //const clock = new THREE.Clock();

      var MyUpdateLoop = function ( )
      {
        renderer.render(scene,camera);
        //customMaterial.uniforms.time.value = clock.getElapsedTime();
        requestAnimationFrame(MyUpdateLoop);
      };

      requestAnimationFrame(MyUpdateLoop);

      //this function is called when the window is resized
      var MyResize = function ( )
      {
        //get the new sizes
        var width = window.innerWidth;
        var height = window.innerHeight;
        //then update the renderer
        renderer.setSize(width,height);
        //and update the aspect ratio of the camera
        camera.aspect = width/height;
        //update the projection matrix given the new values
        camera.updateProjectionMatrix();

        //and finally render the scene again
        renderer.render(scene,camera);
      };
      //link the resize of the window to the update of the camera
      renderer.render(scene,camera);
      window.addEventListener( 'resize', MyResize);
      // document.addEventListener( 'keydown', rotatefakeObject);
      // document.addEventListener( 'mousemove', objectPlacer );
      document.addEventListener( 'mousedown', onDocumentMouseDown );

    </script>
  </body>
</html>
